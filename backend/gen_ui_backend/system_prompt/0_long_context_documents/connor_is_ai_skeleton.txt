Here's a comprehensive code skeleton that captures the system architecture of the provided codebase, focusing on the structural hierarchy, backend and frontend components, integration points, and code organization.

### 1. STRUCTURAL HIERARCHY

#### Backend
```python
# Core interfaces and protocols
from typing import Protocol, Any

class BaseService(Protocol):
    """Define core service behavior."""
    async def process(self) -> None:
        pass

# Abstract base classes
class BaseModel:
    """Base class for all models."""
    pass

# Key service definitions
class UserService(BaseService):
    """User management operations."""
    async def get_user(self, id: str) -> User:
        pass

class ChatService(BaseService):
    """Chat session management operations."""
    async def create_session(self, user_id: str) -> ChatSession:
        pass

# Type definitions and data models
class User(BaseModel):
    user_id: str
    email: str

class ChatSession(BaseModel):
    session_id: str
    user_id: str

# Component hierarchies
# - UserService
# - ChatService

# Integration points
# - Database (PostgreSQL)
# - External APIs (OpenAI, GitHub, Weather)
```

#### Frontend
```typescript
// TypeScript interfaces and types
interface User {
    id: string;
    email: string;
}

interface ChatMessage {
    sender: 'user' | 'bot';
    content: string;
    timestamp: Date;
}

// React component hierarchies
function ChatComponent() {
    // Component logic
}

function UserComponent() {
    // Component logic
}

// Custom hooks and their signatures
function useChat() {
    // Hook logic
}

// State management structures
const chatState = {
    messages: [] as ChatMessage[],
    currentUser: null as User | null,
};

// API client interfaces
async function fetchUser(userId: string): Promise<User> {
    // Fetch user logic
}

// Utility functions
function formatDate(date: Date): string {
    return date.toLocaleString();
}
```

### 2. BACKEND SKELETON

```python
# Data models and their relationships
class User(BaseModel):
    user_id: uuid.UUID
    email: str
    sessions: List[ChatSession]  # One-to-many relationship

class ChatSession(BaseModel):
    session_id: uuid.UUID
    user_id: uuid.UUID
    messages: List[ChatMessage]  # One-to-many relationship

# Service layer interfaces and key methods
class UserService(BaseService):
    async def get_user(self, id: str) -> User:
        pass

class ChatService(BaseService):
    async def create_session(self, user_id: str) -> ChatSession:
        pass

# External integrations and tool abstractions
class GithubIntegration:
    async def fetch_repo_info(self, owner: str, repo: str) -> dict:
        pass

class WeatherIntegration:
    async def get_weather(self, city: str, state: str) -> dict:
        pass

# API endpoint definitions
from fastapi import APIRouter

router = APIRouter()

@router.post("/chat-session")
async def create_chat_session(user_id: str):
    pass

@router.get("/user/{user_id}")
async def get_user(user_id: str):
    pass

# Authentication and middleware structures
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Utility and helper interfaces
def get_db_session():
    pass
```

### 3. FRONTEND SKELETON

```typescript
// TypeScript interfaces and types
interface User {
    id: string;
    email: string;
}

interface ChatMessage {
    sender: 'user' | 'bot';
    content: string;
    timestamp: Date;
}

// React component hierarchies
function ChatComponent() {
    // Component logic
}

function UserComponent() {
    // Component logic
}

// Custom hooks and their signatures
function useChat() {
    // Hook logic
}

// State management structures
const chatState = {
    messages: [] as ChatMessage[],
    currentUser: null as User | null,
};

// API client interfaces
async function fetchUser(userId: string): Promise<User> {
    // Fetch user logic
}

// Utility functions
function formatDate(date: Date): string {
    return date.toLocaleString();
}
```

### 4. INTEGRATION POINTS

```python
# External service interfaces
class GithubIntegration:
    async def fetch_repo_info(self, owner: str, repo: str) -> dict:
        pass

class WeatherIntegration:
    async def get_weather(self, city: str, state: str) -> dict:
        pass

# API contracts between frontend and backend
// Example API contract for fetching user
async function fetchUser(userId: string): Promise<User> {
    const response = await fetch(`/api/user/${userId}`);
    return await response.json();
}

// Event and message definitions
interface ChatEvent {
    type: 'message' | 'error';
    payload: ChatMessage | string;
}

// Third-party tool integrations
// Integration with OpenAI for chat responses
class OpenAIIntegration {
    async getResponse(prompt: string): Promise<string> {
        // Call OpenAI API
    }
}

// Authentication flows
async function authenticateUser(email: string, password: string): Promise<User> {
    // Authentication logic
}
```

### 5. CODE ORGANIZATION

```
src/
  ├── backend/       # Backend services
      ├── models/    # Data models
      ├── services/  # Business services
      ├── routes/    # API routes
      ├── utils/     # Utility functions
  ├── frontend/      # Frontend components
      ├── components/ # React components
      ├── hooks/      # Custom hooks
      ├── pages/      # Next.js pages
  └── shared/        # Shared utilities and types
```

### 6. FORMATTING GUIDELINES
- Use proper type hints and generics.
- Include docstrings for major components.
- Show async/await patterns where applicable.
- Define clear interface boundaries.
- Include important decorators.
- Show dependency injection patterns.
- Maintain consistent indentation.

### 7. WHAT TO EXCLUDE
- Implementation details.
- Complex business logic.
- Configuration values.
- Inline comments (use docstrings instead).
- Test code.
- Documentation comments.

### 8. SPECIAL CONSIDERATIONS
- Show both synchronous and asynchronous patterns.
- Include error handling interfaces.
- Show generic type constraints.
- Define event emitters and handlers.
- Show dependency injection patterns.
- Include middleware chains.

This skeleton provides a structured overview of the system architecture, focusing on the key components and their relationships while omitting implementation details as requested.