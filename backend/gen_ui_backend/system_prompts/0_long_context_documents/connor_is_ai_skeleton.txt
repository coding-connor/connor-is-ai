Here's a comprehensive code skeleton that captures the system architecture of the provided codebase, focusing on the structural hierarchy, backend and frontend components, integration points, and overall organization.

### 1. STRUCTURAL HIERARCHY

#### Backend
```python
# Core interfaces and protocols
from typing import Protocol, Any

class BaseService(Protocol):
    """Define core service behavior."""
    async def process(self) -> None:
        pass

# Abstract base classes
class BaseModel:
    """Base class for all models."""
    pass

# Key service definitions
class UserService(BaseService):
    """User management operations."""
    async def get_user(self, id: str) -> User:
        pass

class ChatService(BaseService):
    """Chat session management operations."""
    async def create_session(self, user_id: str) -> ChatSession:
        pass

# Type definitions and data models
from sqlmodel import Field, SQLModel
import uuid
from datetime import datetime

class User(BaseModel, table=True):
    user_id: uuid.UUID = Field(default_factory=uuid.uuid4, primary_key=True)
    email: str

class ChatSession(BaseModel, table=True):
    session_id: uuid.UUID = Field(default_factory=uuid.uuid4, primary_key=True)
    user_id: uuid.UUID
    started_at: datetime
    ended_at: datetime

# Component hierarchies
# - UserService
# - ChatService

# Integration points
# - Database (PostgreSQL)
# - External APIs (OpenAI, GitHub, Weather)
```

#### Frontend
```typescript
// TypeScript interfaces and types
interface User {
    id: string;
    email: string;
}

interface ChatSession {
    sessionId: string;
    userId: string;
    startedAt: Date;
    endedAt?: Date;
}

// React component hierarchies
import React from "react";

const ChatComponent: React.FC<{ session: ChatSession }> = ({ session }) => {
    return <div>{session.sessionId}</div>;
};

// Custom hooks and their signatures
import { useState } from "react";

function useChat() {
    const [messages, setMessages] = useState<string[]>([]);
    const sendMessage = (message: string) => {
        setMessages((prev) => [...prev, message]);
    };
    return { messages, sendMessage };
}

// State management structures
// Using React's useState and useContext for state management

// API client interfaces
async function fetchChatSession(userId: string): Promise<ChatSession> {
    const response = await fetch(`/api/chat-session/${userId}`);
    return response.json();
}

// Utility functions
function formatDate(date: Date): string {
    return date.toLocaleString();
}
```

### 2. BACKEND SKELETON

```python
# Data models and their relationships
class ChatMessage(BaseModel, table=True):
    message_id: uuid.UUID = Field(default_factory=uuid.uuid4, primary_key=True)
    session_id: uuid.UUID
    sender: str
    content: str
    timestamp: datetime

# Service layer interfaces and key methods
class ChatService(BaseService):
    async def add_message(self, session_id: str, message: ChatMessage) -> None:
        pass

# External integrations and tool abstractions
# - OpenAI API for chat responses
# - GitHub API for repository data
# - Weather API for weather data

# API endpoint definitions
from fastapi import APIRouter

router = APIRouter()

@router.post("/chat")
async def create_chat_session(user_id: str):
    pass

@router.post("/chat/message")
async def add_chat_message(session_id: str, message: ChatMessage):
    pass

# Authentication and middleware structures
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Utility and helper interfaces
def get_db_session():
    pass
```

### 3. FRONTEND SKELETON

```typescript
// TypeScript interfaces and types
interface ChatMessage {
    id: string;
    content: string;
    sender: "user" | "bot";
}

// React component hierarchies
const Chat: React.FC = () => {
    return <div>Chat Component</div>;
};

// Custom hooks and their signatures
function useChat() {
    const [messages, setMessages] = useState<ChatMessage[]>([]);
    const sendMessage = (message: ChatMessage) => {
        setMessages((prev) => [...prev, message]);
    };
    return { messages, sendMessage };
}

// State management structures
// Using React's useState and useContext for state management

// API client interfaces
async function fetchChatMessages(sessionId: string): Promise<ChatMessage[]> {
    const response = await fetch(`/api/chat/${sessionId}`);
    return response.json();
}

// Utility functions
function formatMessage(message: ChatMessage): string {
    return `${message.sender}: ${message.content}`;
}
```

### 4. INTEGRATION POINTS

```python
# External service interfaces
# - OpenAI for chat responses
# - GitHub for repository data
# - Weather API for weather data

# API contracts between frontend and backend
# - POST /chat-session to create a new chat session
# - POST /chat/message to add a new message to a session

# Event and message definitions
# - ChatMessage structure for messages exchanged in chat

# Third-party tool integrations
# - Calendly for scheduling meetings
# - GitHub for fetching repository data

# Authentication flows
# - Clerk for user authentication
```

### 5. CODE ORGANIZATION

```
src/
  ├── backend/       # Backend services
      ├── models/    # Data models
      ├── services/  # Business logic services
      ├── routes/    # API routes
      ├── utils/     # Utility functions
  ├── frontend/      # Frontend components
      ├── components/ # Reusable components
      ├── hooks/      # Custom hooks
      ├── pages/      # Next.js pages
  └── shared/        # Shared utilities and types
```

### 6. FORMATTING GUIDELINES
- Use proper type hints and generics.
- Include docstrings for major components.
- Show async/await patterns where applicable.
- Define clear interface boundaries.
- Include important decorators.
- Show dependency injection patterns.
- Maintain consistent indentation.

### 7. WHAT TO EXCLUDE
- Implementation details.
- Complex business logic.
- Configuration values.
- Inline comments (use docstrings instead).
- Test code.
- Documentation comments.

### 8. SPECIAL CONSIDERATIONS
- Show both synchronous and asynchronous patterns.
- Include error handling interfaces.
- Show generic type constraints.
- Define event emitters and handlers.
- Show dependency injection patterns.
- Include middleware chains.

This skeleton provides a structured overview of the system architecture, focusing on the key components and their relationships while omitting implementation details as requested.